\section{Vorlesung 1 - 17.04.}
\subsection{Was sind Programmiersprachen?}
Programmiersprachen sind künstliche, formale Ausdruckssprachen zur Kommunikation zwischen Mensch und Maschine.\\
\marginnote{Memo technischer Begriff -> z.b. ADD reg1 reg2}[4cm]
Beim Studium von Sprachen unterscheidet man 3 Ebenen(Aspekte):\\
\begin{compactitem}
	\item Syntax einschließlich lexikalischer Struktur (Themen des Übersetzerbaus)\\
	\begin{compactitem}
		\item Kern der Syntax ist die grammatikalische Struktur\\
		\item formale Definition durch kontextfreie Grammatiken\\
	\end{compactitem}
	\item \textbf{Semantik} (diese Vorlesung)\\
	\begin{compactitem}
		\item Bedeutung\\
		\item Interpretation\\
		Natürliche Sprachen (Gegenstand der Geisteswissenschaften) lassen Spielräume zur Interpretation offen. Künstliche Sprachen sollen möglichst formalisierbar sein.
		\item \textbf{Fokus:} Formalisierung
	\end{compactitem}
	\item Pragmatik (Fragen nach dem Gebrauch und Zweck (Useability). \emph{Warum sagt jemand xyz und ist das leicht verständlich?! - Was will jemand damit bewirken?})
\end{compactitem}
\subsection{Mehrdeutigkeit in natürlichen Sprachen}
\begin{compactitem}
	\item [Synonyme]: \emph{Schloss, Schimmel, ...}\\
	Auflösung durch Kontext (meist leicht und unproblematisch)
	\item |Satzebene]: \emph{Dieses Gelände wird zur Verhütung von Straftaten durch die Polizei Videoüberwacht.}\\
	Auflösung durch Hintergrundwissen möglich. 
	weiteres Beispiel \emph{Staatsanwaltschaft ermittelt gegen Betrüger in Clownskostüm.} 
\end{compactitem}

\subsection{Formalisierungsmethoden}
Hier werden drei Formalisierungsmethoden für die Semantik von Programmiersprachen behandelt.\\
\subsubsection*{Motivation}
\begin{compactitem}
	\item Sicherheit beim Programmentwurf\\
	\item Formale verfikation von Eigenschaften\\
	\item Richtlinie Übersetzerbau\\
	\item Automatische Erzeugung von Programm aus Spezifikation\\
\end{compactitem}

\subsubsection*{Entwicklung der Formalisierungsansätze}
\begin{compactitem}
	\item operationelle Semantik (historisch etwas später)\\
	Man stützt die Bedeutung auf die Funktionsweise technischer und abstrakte Maschinen ab. Dazu macht man die Maschine so einfach wie möglich und erkläre die Wirkung der Befehle auf die Maschine. (Landin 1964) - Diese Semantik ist ähnlich ähnliche wie die notationelle Semantik (mathematische Notation), jedoch wirklich näher an der Maschine\\
	\item \textbf{denotationelle Semantik} (etwas früher - fast zeitgleich)\\ 
	Formales erfassen durch mathematische Notation. Weitgehende Abstraktion vom Zustandsraum mit einer direkten Zuordnung von syntaktischen Komponenten zu mathematischen Objekten (Semantik). (McCarthy 1962)\\
	\item axiomatische Semantik\\
	Veränderung/Transformation von Bedingungen/Prädikaten auf dem Zustandsraum (einer abstrakten Maschine).\\
	Das geschieht mit mathematischen Formeln. z.B.: Hoareformel: {Q}P{R}\\
\end{compactitem}

\subsection{Referenzsprache}
Um alle drei Formalisierungsmethoden zu betrachten nutzen wir die Referenzsprache \textbf{WHILE}.
\subsubsection{Definition der Syntax}
\emph{(Wie ist die Sprache grammatikalisch aufgebaut?!)}
\begin{compactitem}
	\item Elementare Einheiten\\
	\begin{lstlisting}
// ganze Zahlen
Z::= 0 |1|...|MAX|-1|-2|...|MIN #ZAHL (endlicher Ausschnitt der ganzen Zahlen MIN+1 .. MAX)
// Wahrheitswerte BOOL
W::= TRUE | FALSE
// Konstanten KON
K::= Z | W
// Bezeichner bzw. Variablen mit Indizes
T::= a|b|...|z|a1|a2|...|zi
// Operatoren
OP::= + | - | * | / | mod
// boolesche Operatoren
BOP::= < | > | = | !> | !< | !=
	\end{lstlisting}
	\item Zusätzliche Einheiten (induktiv)\\
	Die Indizes sind dazu da das Vorkommen von Symbolen in der Struktur eindeutig zu beschreiben.\\
	\begin{lstlisting}
// Terme TERM
T::= Z  |  I  |  T1 OP T2 | read, für T1,T2 in TERM
// boolesche Terme BT
B::= W | T1 BOP T2 | read | not B
// Befehle (Zustandstransformation) COM
C::= skip | I := T | C1;C | if B then C1 else C2 | while B do C |  output T | output B
	\end{lstlisting}
\end{compactitem}
Warum braucht man für so eine Sprache eine formale Semantik?!\\
Ich möchte maschinell arbeiten und es gibt Unterspezifikationen, unklar ist das Verhalten bei:
\begin{compactitem}
\item Typkonflikte\\
\item Fehlerbehandlung\\
\item Rekursion\\
\end{compactitem}

\subsubsection*{Syntax ist mehrdeutig?!}
\begin{lstlisting}
while B do C1; C2
\end{lstlisting}
% beide Bäume zeichnen!
\begin{lstlisting}
while B do 
	C1; 
	C2;
\end{lstlisting}






