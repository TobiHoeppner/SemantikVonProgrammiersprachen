\section{Vorlesung 5 - 22.05.}
\subsection{Denotationelle Semantik}
% auf hohe Notation:Funktionen
\marginnote{\small\emph{(Klammern sparen!)}}[2,5cm]
% höhe B.1.
\marginnote{\small\emph{(Abh. vom Speicher + Nebenwirkung)}}[3,5cm]

% höhe \mathcal{C}[\underline{skip}] z &= z
\marginnote{\small\emph{alternative Schreibweise:}}$\mathcal{C}[\underline{skip}] z &= \underline{id}$[6,5cm]

\textbf{Grundprinzip:} Direkte (injektive) Zuordnung von syntaktischen Strukturen zu deren Semantik (als mathematisches Objekt (Konstrukt)).

\begin{compactitem}
	\item[\textbf{A}] Allgemeines Prinzip (am Beispiel von WHILE)\\
	\begin{compactitem}
		\item[1.] Ordne jeder syntaktischen Kategorie $K$ der Sprache einen semantischen Bereich $B_K$ zu.
		\item[2.] Schreibe (definiere) zu jeder syntaktischen Kategorie eine Semantikfunktion $\mathcal{K}$\\
		$\mathcal{K}:K \rightarrow B_K$
	\end{compactitem}
	\textbf{Notation:}
	\begin{compactitem}
		\item[-] Das Argument einer Semantikfunktion $\mathcal{K}$ schreiben wir in []
		\item[-] Funktionen z.B. $f: A \rightarrow (B \rightarrow C)$ werden $f a b = a \dots b \dots $ 
	\end{compactitem}
	\item[\textbf{B}] Denotationelle Semantik von WHILE
	\begin{compactitem}
		\item[-] Syntaktische Kategorien von WHILE: TERM, BT, COM, PROG
		\item[-] Hilfsbereiche: ZUSTAND = SPEICHER $\times$ EINGABE $\times$ AUSGABE mit SPEICHER = ID $\rightarrow$ ZAHL $\cup \{\underline{frei}\}$, EINGABE = KON$^*$ und AUSGABE = KON$^*$
		\item[1.] $\mathcal{T}:$TERM$\rightarrow \underline{\underline{B_T}}$\\
		$B_T :=$ZAHL???
		\begin{compactitem}
		% versuchen als kleinen Einschub auf Höhe B.1. zu ordnen
			\item[Curry-Isomorphie] $(A \times B \rightarrow) \cong A \rightarrow (B \rightarrow C)$\\
			% Runder Pfeil oben mit "curry" von links nach rechts(spitze)
			% Runder Pfeil unten mit "uncurry" von rechts nach links(spitze)
			curry $f a b = f(a,b)$\\
			uncurry $g (a,b) = g a b$
		\end{compactitem}
		$B_T := $ SPEICHER $\rightarrow$ EINGABE $\rightarrow$ ((ZAHL $\times$ Eingabe) $\cup \{\underline{Fehler} \}$ )\\
		$\mathcal{B}:$BT $\rightarrow $ SPEICHER $\rightarrow$ EINGABE $\rightarrow$ ((BOOL $\times$ Eingabe) $\cup \{\underline{Fehler} \}$ )\\
		$\mathcal{C}:$COM $\rightarrow $ ZUSTAND $\rightarrow$ (ZUSTAND $\cup \{\underline{Fehler} \}$ )\\
		% geschwungene Klammer mit $B_C$unter ZUSTAND -> (...)
		\item[2.] Induktive Definition über dem Aufbau\\
		\begin{align*}
		\mathcal{T}[n] s e &= (n,e) &\text{für alle} n \in \text{ZAHL}\\
% geschwungene Klammer 2 Reihen!
		\mathcal{T}[x] s e &= (n,e)\text{ , falls} s x = n \in \text{ZAHL} &\text{für alle} x \in \text{ID}\\
		 &= \text{Fehler , falls} s x = \underline{frei}  &\text{für alle} x \in \text{ID}\\
% geschwungene Klammer 2 Reihen!		
		\mathcal{T}[\underline{read}] s e &= (n,e')\text{ , falls } e = n.e'\\
		&= \text{Fehler , falls} e = \mathcal{E} \text{ oder } e = b.e' \text{ mit } b \in \text{BOOL}\\
% geschwungene Klammer 2 Reihen! Der erste Fall hat zwei Fallunterscheidungen für T1 und T2, die sollen hinter dem falls untereinader stehen
		\mathcal{T}[\underline{T_1 \; \underline{OP}\; T_2}] s e &= (n,e'') \text{, falls } \mathcal{T} [T_1] s e = (n_1,e') und \\  \mathcal{T} [T_2] s e' = (n_2,e'') \text{ und } \underline{n_1\;\underline{OP}\;n_2} = n \in \text{ZAHL}\\
		&= \underline{Fehler}\tex{, sonst}\\
		\\
		\mathcal{B}[w] s e &= (w,e) &\text{für alle} w \in \text{BOOL}\\
% geschwungene Klammer 2 Reihen!		
		\mathcal{B}[\underline{not}B] s e &= (b,e') &\text{ falls } \mathcal{B}[B]s e = (w, e') \text{ und } b = \not w\\
		&=\underline{Fehler}\text{, sonst}\\
% geschwungene Klammer 2 Reihen!		
		\mathcal{B}[T_1\;\underline{BOP}\;T_2] s e &= (b,e'') \text{, falls } \mathcal{T} [T_1] s e = (n_1,e') und \\  \mathcal{T} [T_2] s e' = (n_2,e'') \text{ und } \underline{n_1\;\underline{BOP}\;n_2} = b \in \text{BOOL}\\
		&= \underline{Fehler}\tex{, sonst}\\
% geschwungene Klammer 2 Reihen!		
		\mathcal{B}[\underline{read}] s e &= (b,e')\text{ , falls } e = b.e' \text{ mit } b \in \text{BOOL}\\
		&= \text{Fehler , falls} e = \mathcal{E} \text{ oder } e = n.e' \text{ mit } n \in \text{ZAHL}\\
		\\
		\mathcal{C}[\underline{skip}] z &= z\\
% geschwungene Klammer 2 Reihen!		
		\mathcal{C}[I:=T] (s,e,a) &= (S[n/I], e', a)\text{, falls} \mathcal{T}[T] s e = (n, e')\\
		&= \underline{Fehler}\text{, sonst}\\
% geschwungene Klammer 2 Reihen!		
		\mathcal{C}[\underline{output}\;T] (s,e,a) &= (s,e',a.n)\text{, falls} \mathcal{T}[T]s e = (n,e')\\
		&= \underline{Fehler}\text{, sonst}\\
% geschwungene Klammer 2 Reihen!			
		\mathcal{C}[\underline{output}\;B] (s,e,a) &= (s,e',a.b)\text{, falls} \mathcal{B}[B]s e = (b,e')\\
		&= \underline{Fehler}\text{, sonst}\\
% geschwungene Klammer 2 Reihen!			
		\mathcal{C}[C_1;C_2] z &= \mathcal{C} [C_2] z', mathcal{C} [C_1] z = z' \text{ mit } z' \in \text{ZUSTAND}\\
		&= \underline{Fehler}\text{, sonst}\\
% geschwungene Klammer 3 Reihen!			
		\mathcal{C}[\underline{if}\;B \underline{then}\;C_1\;\underline{else}\;C_2] (s,e,a) &= \mathcal{C} [C_1] (s,e',a) \text{, falls } \mathcal{B}[B] s e = (\underline{true}, e')\\
		&= \mathcal{C} [C_2] (s,e',a) \text{, falls } \mathcal{B}[B] s e = (\underline{false}, e')\\
		&= \underline{Fehler}\text{, sonst}\\
% geschwungene Klammer 3 Reihen!				
		\mathcal{C}[\underline{while}\;B \underline{do}\;C] (s,e,a) &= \mathcal{C}[C;\underline{while}\;B \underline{do}\;C](s,e',a)\text{, falls }\mathcal{B}[B]s e = (\underline{true}, e')\\
		&= (s,e',a)\text{, falls }\mathcal{B}[B]s e = (\underline{false}, e')
		&= \underline{Fehler}\text{, sonst}\\
		\\
% geschwungene Klammer 3 Reihen!
		\mathcal{P}[P]e &= a\text{, falls } \mathcal{C}[C](s_0,e,\epsilon) = (s, e', a) \\
		&= \text{Fehler, falls} \mathcal{C}[C](s_0,e,\epsilon) = \underline{Fehler}\\
		&= \text{undefiniert sonst}
		\end{align*}
	\end{compactitem}
\end{compactitem}